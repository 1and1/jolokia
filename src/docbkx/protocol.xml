<?xml version="1.0" encoding="UTF-8"?>
<chapter id="protocol">
    <title>Jolokia Protocol</title>
    <para>
      Jolokia uses JSON over HTTP for its communication. This document
      specifies the format of the JSON requests and responses exchanged
      between an Jolokia agent and its clients. The communication is based
      on HTTP as the transport protocol and hence follows a request-response
      paradigm. 
    </para>
    <para>
      Requests can be sent in two ways: Either as a HTTP GET request, in
      which case the request parameters are encoded in the URL. Or as a
      POST request where the request is extracted from a JSON payload.
      The former is suitable for simple request (and for testing the agent
      via a browser) whereas POST requests are more appropriate for complex
      requests. E.g. bulk requests are only possible with POST. (Keep in mind
      that many web servers log the requested path of every request, including
      parameters passed to a GET request, so posting messages over GET
      often bloats server logs.)
    </para>
    <para>
      The response returned by the agent uses JSON for the data
      representation. 
    </para>
    <section id="version">
      <title>Version</title>
      <para>
        This document describes Version 4 of the Jolokia agent protocol. 
      </para>
    </section>
    <section id="request">
      <title>Request</title>
      <para>
        Jolokia knows about two different styles for handling requests, which
        are distinguished by the HTTP method used, GET or POST.
      </para>
      <para>
        For GET requests it uses restful style, which essentially is a
        single URL which encodes all requests parameters. For this to
        work, the URL is divided into parts separated by
        <literal>/</literal>. In general, the request URL looks like
        <synopsis><![CDATA[
 <base-url>/<mode of operation>/<operation specific parameter>/..../]]></synopsis>
      </para>
      <para>
        The <literal>&lt;base-url&gt;</literal> specifies the URL
        under which the Jolakia agent is accessible in general. It
        typically looks like <uri>http://localhost:8080/jolokia</uri>,
        but depends obviously on your deployment setup. Normally, the
        last part of this URL is the name of the deployed agent, which
        by default is based on the filename
        (e.g. <filename>jolokia.war</filename>).  <literal>&lt;mode of
        operation&gt;</literal> specifies one of the supported
        operations after which operation-specific parameters follow.
      </para>
      <para>
        In addition to the command provided as a path, the agent knows about
        some query parameters which influence the value returned. These are
        described in <xref linkend="queryparams"/>
      </para>
      <para>
        For POST the complete request is specified in the POST content. This
        content is a JSON representation of the JMX request. Beside the
        operations available for a simple GET request, POST requests can
        contain additional parameters, e.g. for specifying a
        proxy. Additionally, with POST request you can submit multiple JMX
        request at a time to process bulk operations and minimizing turnaround
        times.
      </para>
      <para>
        The supported operations are described now in the following
        sections.
      </para>
      <section id="get-requests">
        <title>GET-Requests</title>
        <section id="read">
          <title>read</title>
          <para>
            Mode used for reading an JMX attributes. The operation specific parameters have
            the following format.
            <synopsis><![CDATA[<mbean name>/<attribute name>/<inner path>]]></synopsis>
            <variablelist>
              <varlistentry>
                <term>mbean name (mandatory)</term>
                <listitem>
                  <para>
                    The canonical name of the MBean for which the
                    attribute should be fetched. Please refer to the
                    JMX documentation for the definition of a
                    <emphasis>canonical name</emphasis>. In short, it
                    contains two parts: A domain part and a list of
                    properties which are separated by
                    <literal>:</literal>. Properties themselves are
                    combines in a comma separated list of key-value
                    pairs. Example:
                  </para>
                  <informalexample>
                    <literallayout>
java.lang:type=Memory
java.lang:name=Code Cache,type=MemoryPool
                    </literallayout>
                  </informalexample>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>attribute name (mandatory)</term>
                <listitem>
                  <para>
                    This is the name of the attribute which is requested.                   
                  </para>
                  <informalexample>
                    <literallayout>
HeapMemoryUsage
SystemProperties
                    </literallayout>
                  </informalexample>           
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>inner path (optional)</term>
                <listitem>
                  <para>
                    This is an optional part which specifies an inner
                    path within the attribute's type. j4p agent knows
                    how to serialize certain complex data types with
                    JSON, i.e. collections and
                    <literal>CompositeData</literal>. Please refer to
                    the next section for more details about JSON
                    serialization. An <emphasis>inner path</emphasis>
                    can be used to specify a certain substructure
                    (plain value, array, hash) within the returned
                    complex attribute value. Think of it as something
                    like "XPath lite". This is best explained by an
                    example:
                  </para>
                  <para>
                    The attribute <literal>HeapMemoryUsage</literal> of the MBean 
                    <literal>java.lang:type=Memory</literal> can be
                    requested with the URL 
                    <literal>http://localhost:8080/j4p/read/java.lang:type=Memory/HeapMemoryUsage</literal>
                    which returns a complex JSON structure like
                    <programlisting language="json">
 {
   "committed" : 18292736,
   "used" : 15348352,
   "max" : 532742144,
   "init" : 0
 }</programlisting>
                  </para>
                  <para>
                    In order to get to the value for used heap memory
                    you should specify an inner path
                    <literal>used</literal>, so that the request
                    <literal>http://localhost:8080/j4p/read/java.lang:type=Memory/HeapMemoryUsage/used</literal>
                    results in a response of
                    <literal>15348352</literal>.  If the attribute
                    contains arrays at some level, use a numeric index
                    as part of the innerpath if you want to traverse
                    into this array.
                  </para>
                </listitem>
              </varlistentry>              
            </variablelist>
          </para>
        </section>
        <section id="write">
          <title>write</title>
          <para>
            Writing an attribute is quite similar to reading, except that the URL takes an
            additional <literal>value</literal> element:
            <synopsis><![CDATA[<mbean name>/<attribute name>/<value>/<inner path>]]></synopsis>
          </para>
          <variablelist>
            <varlistentry>
              <term>mbean name (mandatory)</term>
              <listitem>
                <para>
                  The MBean name as described above (see <xref linkend="read"/> for details)
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>attribute name (mandatory)</term>
              <listitem>
                <para>
                  The attribute name (see <xref linkend="read"/> for details)
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>value (mandatory)</term>
              <listitem>
                <para>
                  The value to set in its string representation. Note,
                  that only values can be set, which have one for the
                  following types:
                  <itemizedlist>
                    <listitem>String</listitem>
                    <listitem>Integer / int</listitem>
                    <listitem>Long / long</listitem>
                    <listitem>Boolean / boolean</listitem>
                    <listitem>Array or List of the types above, separated by commas</listitem>
                  </itemizedlist>
                </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>inner path (optional)</term>
              <listitem>
                <para>
                  An optional inner path for specifying an inner object on which to set the
                  value. See <xref linkend="read"/> for more on inner pathes.
                </para>
              </listitem>
            </varlistentry>
          </variablelist>
          <informalexample>
            <para>
              For example, you can set the garbage collector to verbose mode by using
              something like
            </para>
            <literallayout class="monospaced">http://localhost:8080/j4p/write/java.lang:type=Memory/Verbose/true</literallayout>            
          </informalexample>
        </section>
        <section id="exec">
          <title>exec</title>
          <para>
            With this mode, you can execute a JMX operation on a target MBean. The format
            of this looks like
            <synopsis><![CDATA[<mbean name>/<operation name>/<arg1>/<arg2>/....]]></synopsis>
          </para>
        </section>
      </section>
    </section>



=head3 exec


  
  
=over

=item C<mbean name> (mandatory)

The MBean name as described above (see L</"read"> for details)

=item C<operation name> (mandatory)

Name of the operation to execute

=item C<arg1>, C<arg2>, ...

String representation for the arguments required to execute this
operation. Only certain data types can be used here as desribed for the
L</"write"> mode.

=back

For example, to execute a garbage collection you use

  http://localhost:8080/j4p/exec/java.lang:type=Memory/gc

=head3 search

This mode is used to query for certain MBean. It takes a single argument for
specifying the search parameter like in 

   http://localhost:8080/j4p/search/*:j2eeType=J2EEServer,*

You can use patterns as described in
L<http://java.sun.com/j2se/1.5.0/docs/api/javax/management/ObjectName.html>,
i.e. it may contain wildcars like C<*> and C<?>. The Mbean names matching the
query are returned as a list within the response.

=head3 list

The list operation allows you to get information about the accessible
MBeans. This information includes the MBean names, their attributes and
operations along with type information and description (as far as they are
provided by the MBean author which doesn't seem to be often the case). 

A list-request can take these specific, optional,  parameters

  <inner path>

=over

=item C<inner path> (optional)

The I<inner path>, as above, specifies a subset of the complete response. You
can use this to select a specific domain, MBean or attribute/operation. See
below for the format of the complete answer. 

=back 

=head3 Escaping

If you are forced to use a slash (C</>) as part of your request (e.g. as part
of you bean's name) you need to escape it. A single slash (C</>) is escaped by
the combination C</-/>, two subsequent slashes (C<//>) are to be escaped with
C</--/> and so on. For example, to request the atrribute C<State> on the MBean
named C<jboss.jmx:alias=jmx/rmi/RMIAdaptor>, you should an URL like

  .../read/jboss.jmx:alias=jmx/-/rmi/-/RMIAdaptor/State

L<JMX::Jmx4Perl::Agent> does this sort of escaping transparently. If the part
(e.g. MBean's name) I<ends> in a slash you need to use a C<+> instead of a
minus, so the j4p agent can combine parts properly. The corresponding perl code
for creating such a format looks like

  $input =~ s|(/+)|"/" . ('-' x length($1)) . "/"|eg;
  $input =~ s|-/$|+/|; # The last slash needs a special escape

You might wonder, why simple URI encoding isn't enough for escaping
slashes. The reason is rather simple: JBoss/Tomcat has a nasty bug, which
returns an HTTP response C<HTTP/1.x 400 Invalid URI: noSlash> for any URL which
contains an escaped slash in the path info (i.e. C<%2F>). Other appservers
might croak as well, though not test. Try it yourself!

=head2 POST Requests

All operations as desrcibed above are available for post requests as well. In
its most general form, the content of a POST has the following format:

 [
  {
    "attribute":"HeapMemoryUsage",
    "mbean":"java.lang:type=Memory",
    "path":"used",
    "type":"READ"
  },
  { 
    "mbean":"*:type=Memory,*",
    "type":"SEARCH"
  }
 ]

In this case, multiple request are represented as a JSON array with maps, where
the map's entries are the single request's attribute along with its value. For
a single request, the array can be omitted. Depending on whether you send an
array of requests or a single request you get an array of responses or a single
response as result.

The parameters known to a single request are:

=over

=item type

Operational type as defined in L<JMX::Jmx4Perl::Request> (C<"READ">,
C<"WRITE">, C<"EXEC">, C<"LIST">, C<"SEARCH">)

=item mbean

Name of the targetted mbean in its canonical format. 

=item attribute

If type is C<READ> or C<WRITE> this specifies the requested
attribute

=item value

For C<WRITE> this specifies the value to set

=item arguments

List of arguments of C<EXEC> operations

=item path

Inner path 

=item max_depth, max_objects, max_list_size

Optional parameters in order to influence the size of the returned JSON
response. 

=back

=head1 RESPONSE

As already mentioned, the response is an HTTP response containing a JSON
payload. This section describes the format of the retuned answer, depending on
the operation mode. In general, two kinds of responses can be classified: In
the normal case, a HTTP Response with response code 200 is returned, containing
the result of the operation as a JSON payload. In case of an error, a 4xx or
5xx code will be returned and the JSON payload contains details about the error
occured.

In the non-error case, the top-level JSON response objects contains a C<value>,
a C<status> of 200 and a C<request>, which encapsulated the original
request. This C<request> has as members a C<type> member for the operational
mode ("read", "list", ...) and additional entries containing the operation
specific parameters as given in the request URL. 

=head2 read

A typical response for an attribute read operation for an URL like 

 http://localhost:8080/j4p/java.lang:type=Memory/HeapMemoryUsage/

looks like 

 {
   "value":{
             "init":134217728,
             "max":532742144,
             "committed":133365760,
             "used":19046472
           },
   "status":200,
   "timestamp":1244839118,
   "request":{
               "mbean":"java.lang:type=Memory",
               "type":"read",
               "attribute":"HeapMemoryUsage"
             },
   "history":[{"value":{
                         "init":"134217728",
                         "max":"532742144",
                         "committed":"133365760",
                         "used":"18958208"
                       },
               "timestamp":1244839045
             }, ....
             ]
 }

As you can see, the C<value> contains the attribute's value, either as a
single, simple value if the attribute has a primitive type, or a complex JSON
structure (containing maps and arrays) if the attribute has a more complex type
understood by the F<j4p> agent. For complex object types, which can not be
serialized by the F<j4p> agent directly, bean properties (i.e public,
no-argument C<get> methods on the Java objects) are examined recursively up to
a maximum depth. You can influence the traversal by providing regular HTTP
query parameters to the request URL. The known parameters are 

=over 

=item maxDepth

Maximum depth of the tree traversal into a bean's properties. The maximum value
as configured in the agent's F<web.xml> is a hard limit and cannot be exceeded
by a query parameter (5)

=item maxCollectionSize

For collections (lists, maps) this is the maximum size. By default, no limit
applies to collections

=item maxObjects

Number of objects to visit in total. A hard limit can be configured in the
agent's F<web.xml> deployment descriptor. (10000)

=back

If bean serialization is used, certain special values indicate some special
treatment: 

=over

=item [this]

This label is used when a property contains a self reference 

=item [Depth limit .... ]

When a depth limit is used or the hard depth limit is exceeded, this label
contains a string representation of the next object one level deeper. 

=item [Reference .... ]

If during the traversal an object is visited a second time, this label is
used in order to break the cycle. 

=item [Object limit exceeded]

The total limit of object has been exceeded and hence the object are not
deserialized further.

=back 

For a successul request the C<status> is always C<200>.  C<timestamp> contains
the timestamp (i.e. epoch seconds) when the attribute was read on the server.

Optionally, a C<history> entry might be present. This is the case, when
I<history tracking> is switched on. See L<jmx4perl> how to do this, in short,
you have to execute an JMX operation on certain, jmx4perl specific MBean to
turn it on. If this is the case, C<history> contains an array of json object,
which have two attribute: C<value> containing the historical value (which can
be as complex as any value) and C<timestamp> indicating the time when this
value was current. 

The C<request>'s attribute are:

=over

=item mbean

name of the requested MBean

=item attribute

attribute name

=item type 

is always C<read>

=item path 

an optional path, if provided in the request.

=back

=head2 write

As response for a writing operation you get back the old value if the value was
set. For a request 

  http://localhost:8080/j4p/write/java.lang:type=ClassLoading/Verbose/true

you get the answer (supposed that verbose mode was switched off for class
loading at the time this request was sent)

 { 
   "value":"false",
   "status":200,
   "request": {
                "mbean":"java.lang:type=ClassLoading",
                "type":"write",
                "attribute":"Verbose",
                "value":"true"
              }
 }

The response is quite similar to the read operation except for the additional
C<value> element in the request (and of course, the different C<type>). 

=head2 exec 

For an C<exec> operation, the response contains the return value of the
opeartion. C<null> is returned if either the operation return a null value or
the operation is declared as void. A typical response for an URL like

 http://localhost:8080/j4p/exec/java.util.logging:type=Logging/setLoggerLevel/global/INFO

looks like

 {
   "value":null,
   "status":200,
   "request": {
                "type":"exec",
                "mbean":"java.util.logging:type=Logging",
                "operation":"setLoggerLevel",
                "arguments":["global","INFO"]
              }
}

=head2 search

Searching for MBean names is done with the C<search> operation. As single
argument a MBean search pattern like C<*:j2eeType=J2EEServer,*> has to be
provided. The answer is a list of MBean names which matches the pattern. A 404
Response will be returned in case no MBean matches this name. 

Example:

  http://localhost:8888/j4p/search/*:j2eeType=J2EEServer,*

results in 

 {
   "value": [
              "jboss.management.local:j2eeType=J2EEServer,name=Local"
            ],
   "status":200,
   "timestamp":1245305648,
   "request": {
       "mbean":"*:j2eeType=J2EEServer,*","type":"search"
   }
 }

=head2 list

The list operation (without a I<path>) returns a JSON object containing a
C<value>, C<status> and C<request> member as for C<read> operations. 

The C<value> has the following format:
  
 { 
  <domain> : 
  {
    <prop list> : 
    {
      "attr" : 
      {
        <attr name> : 
        { 
          "type" : <attribute type>,
          "desc" : <textual description of attribute>,
          "rw"   : true/false
        },
        ....
      }, 
      "op" :
      {
         <operation name> :
         {
           "args" : [
                      { 
                       "type" : <argument type>
                       "name" : <argument name>
                       "desc" : <textual description of argument>
                      },
                      .....
                     ],
           "ret"  : <return type>,
           "desc" : <textual description of operation>
         }, 
         .....
      }
    }, 
    ....
  },
  ....
 }

The C<domain name> and the C<property list> together uniquely identify a single
MBean. The property list is in the so called I<canonical order>, i.e. in the
form "<key1>=<val1>,<key2>=<val2>,.." where the keys are ordered
alphabetically. Each MBean has zero or more attributes and operations which can
be reached in an MBeans JSON object with the keys C<attr> and C<op>
respectively. Within these groups the contained information is explained above
in the schema and consist of Java types for attributes, arguments and return
values, descriptive information and whether an attribute is writable (C<rw ==
true>) or read-only. 

As for reading attributes you can fetch a subset of this information using an
path. E.g a path of C<domain/prop-list> would return the value for a single
bean only. For example, a request 

 http://localhost:8080/j4p/list/java.lang/type=Memory

results in an answer

 {
   "value":
   { 
     "op":
     { 
       "gc":
       {
         "args":[],
         "ret":"void",
         "desc":"gc"
       }
     },
     "attr":
     {
       "NonHeapMemoryUsage":
       {
         "type":"javax.management.openmbean.CompositeData",
         "rw":false,
         "desc":"NonHeapMemoryUsage"
       },
       "Verbose":
       {
         "type":"boolean",
         "rw":true,
         "desc":"Verbose"
       },
       "HeapMemoryUsage":
       {
         "type":"javax.management.openmbean.CompositeData",
         "rw":false,
         "desc":"HeapMemoryUsage"
       },
       "ObjectPendingFinalizationCount":
       {
         "type":"int",
         "rw":false,
         "desc":"ObjectPendingFinalizationCount"
       }
     }
   },
   "status":200,
   "request":
   {
     "type":"list",
     "path":"java.lang\/type=Memory"
   }
 }

=head2 version

A command C<version> returns the version of the underlying L<jmx4perl>
package. The response looks like any other response, the version number itself
is returned as C<value> attribute in the response.

=head2 Error Response

An error response looks like

  {
    "status":400,
    "error":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'",
    "stacktrace":"java.lang.IllegalArgumentException: Invalid request type 'java.lang:type=Memory'\n
                  \tat org.cpan.jmx4perl.JmxRequest.extractType(Unknown Source)\n
                  \tat org.cpan.jmx4perl.JmxRequest.<init>(Unknown Source) ...."
  } 

I.e. the C<status> has a code in the range C<400 .. 499> or C<500 .. 599> as it
is specified for HTTP return codes. The C<error> member contains an error
description while C<stacktrace> contains a Java stacktrace occured on the
server side (if any). 

</chapter>